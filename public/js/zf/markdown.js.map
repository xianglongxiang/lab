{"version":3,"sources":["zf/markdown.js"],"names":["expose","mk_block_toSource","uneval","this","toString","trailing","lineNumber","mk_block_inspect","util","require","inspect","count_lines","str","n","i","indexOf","escapeHTML","text","replace","render_tree","jsonml","tag","shift","attributes","content","length","Array","push","tag_attrs","a","join","convert_tree_to_html","tree","references","options","slice","preprocessTreeNode","attrs","extract_attr","level","code","apply","splice","src","href","ref","original","title","key","merge_text_nodes","strong_em","md","CloseTag","len","len_after","name","state_slot","other_slot","other","state","unshift","res","processInline","substr","last","pop","consumed","concat","split_meta_hash","meta_string","meta","split","parts","in_quotes","letter","MarkdownHelpers","mk_block","block","trail","line","arguments","s","String","toSource","undefined","isArray","obj","Object","prototype","call","forEach","arr","cb","thisp","isEmpty","hasOwnProperty","Markdown","dialect","dialects","Gruber","Error","em_state","strong_state","debug_indent","parse","source","toTree","split_blocks","input","m","re","blocks","line_no","exec","lastIndex","processBlock","next","cbs","ord","__order__","__call__","debug","inline","custom_root","old_tree","b","args","print","console","log","loop_re_over_block","valueOf","buildBlockOrder","d","buildInlinePatterns","patterns","match","l","__patterns__","fn","pattern","renderJsonML","root","toHTMLTree","refs","html","toHTML","DialectHelpers","inline_until_char","want","nodes","charAt","__oneElement__","subclassDialect","Block","Inline","atxHeader","header","setextHeader","ret","block_search","substring","horizRule","contained","lists","regex_for_depth","depth","RegExp","indent_re","any_list","expand_tab","add","li","loose","nl","add_to","what","is_str","get_contained_blocks","x","paragraphify","stack","list","last_li","sublist","bullet_list","is_list_re","make_list","indent","lines","li_accumulate","line_re","wanted_depth","Math","floor","found","next_block","hr","blockquote","prev","abutting","processedBlock","attr","referenceDefn","toLowerCase","para","patterns_or_re","previous_nodes","index","out","]","}","__escape__","\\","![","alt","[","link","orig","children","url","open_parens","<","`","  \n","Maruku","processMetaHash","test","id","document_meta","pairs","p","value","block_meta","hash","node","result","definition_list","tight","terms","defns","table","_split_on_unescaped","ch","r","leading_pipe","no_leading_pipe","html_attrs","align","trim","row","html_row","matches","before","k","window"],"mappings":"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","file":"zf/markdown.js","sourcesContent":["// Released under MIT license\n// Copyright (c) 2009-2010 Dominic Baggott\n// Copyright (c) 2009-2010 Ash Berlin\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n// Date: 2013-09-15T16:09Z\n\n(function(expose) {\n\n\n\n\n  var MarkdownHelpers = {};\n\n  // For Spidermonkey based engines\n  function mk_block_toSource() {\n    return \"Markdown.mk_block( \" +\n            uneval(this.toString()) +\n            \", \" +\n            uneval(this.trailing) +\n            \", \" +\n            uneval(this.lineNumber) +\n            \" )\";\n  }\n\n  // node\n  function mk_block_inspect() {\n    var util = require(\"util\");\n    return \"Markdown.mk_block( \" +\n            util.inspect(this.toString()) +\n            \", \" +\n            util.inspect(this.trailing) +\n            \", \" +\n            util.inspect(this.lineNumber) +\n            \" )\";\n\n  }\n\n  MarkdownHelpers.mk_block = function(block, trail, line) {\n    // Be helpful for default case in tests.\n    if ( arguments.length === 1 )\n      trail = \"\\n\\n\";\n\n    // We actually need a String object, not a string primitive\n    /* jshint -W053 */\n    var s = new String(block);\n    s.trailing = trail;\n    // To make it clear its not just a string\n    s.inspect = mk_block_inspect;\n    s.toSource = mk_block_toSource;\n\n    if ( line !== undefined )\n      s.lineNumber = line;\n\n    return s;\n  };\n\n\n  var isArray = MarkdownHelpers.isArray = Array.isArray || function(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  // Don't mess with Array.prototype. Its not friendly\n  if ( Array.prototype.forEach ) {\n    MarkdownHelpers.forEach = function forEach( arr, cb, thisp ) {\n      return arr.forEach( cb, thisp );\n    };\n  }\n  else {\n    MarkdownHelpers.forEach = function forEach(arr, cb, thisp) {\n      for (var i = 0; i < arr.length; i++)\n        cb.call(thisp || arr, arr[i], i, arr);\n    };\n  }\n\n  MarkdownHelpers.isEmpty = function isEmpty( obj ) {\n    for ( var key in obj ) {\n      if ( hasOwnProperty.call( obj, key ) )\n        return false;\n    }\n    return true;\n  };\n\n  MarkdownHelpers.extract_attr = function extract_attr( jsonml ) {\n    return isArray(jsonml)\n        && jsonml.length > 1\n        && typeof jsonml[ 1 ] === \"object\"\n        && !( isArray(jsonml[ 1 ]) )\n        ? jsonml[ 1 ]\n        : undefined;\n  };\n\n\n\n\n /**\n   *  class Markdown\n   *\n   *  Markdown processing in Javascript done right. We have very particular views\n   *  on what constitutes 'right' which include:\n   *\n   *  - produces well-formed HTML (this means that em and strong nesting is\n   *    important)\n   *\n   *  - has an intermediate representation to allow processing of parsed data (We\n   *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n   *\n   *  - is easily extensible to add new dialects without having to rewrite the\n   *    entire parsing mechanics\n   *\n   *  - has a good test suite\n   *\n   *  This implementation fulfills all of these (except that the test suite could\n   *  do with expanding to automatically run all the fixtures from other Markdown\n   *  implementations.)\n   *\n   *  ##### Intermediate Representation\n   *\n   *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n   *\n   *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n   **/\n  var Markdown = function(dialect) {\n    switch (typeof dialect) {\n    case \"undefined\":\n      this.dialect = Markdown.dialects.Gruber;\n      break;\n    case \"object\":\n      this.dialect = dialect;\n      break;\n    default:\n      if ( dialect in Markdown.dialects )\n        this.dialect = Markdown.dialects[dialect];\n      else\n        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n      break;\n    }\n    this.em_state = [];\n    this.strong_state = [];\n    this.debug_indent = \"\";\n  };\n\n  /**\n   * Markdown.dialects\n   *\n   * Namespace of built-in dialects.\n   **/\n  Markdown.dialects = {};\n\n\n\n\n  // Imported functions\n  var mk_block = Markdown.mk_block = MarkdownHelpers.mk_block,\n      isArray = MarkdownHelpers.isArray;\n\n  /**\n   *  parse( markdown, [dialect] ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *\n   *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n   **/\n  Markdown.parse = function( source, dialect ) {\n    // dialect will default if undefined\n    var md = new Markdown( dialect );\n    return md.toTree( source );\n  };\n\n  function count_lines( str ) {\n    var n = 0,\n        i = -1;\n    while ( ( i = str.indexOf(\"\\n\", i + 1) ) !== -1 )\n      n++;\n    return n;\n  }\n\n  // Internal - split source into rough blocks\n  Markdown.prototype.split_blocks = function splitBlocks( input ) {\n    input = input.replace(/(\\r\\n|\\n|\\r)/g, \"\\n\");\n    // [\\s\\S] matches _anything_ (newline or space)\n    // [^] is equivalent but doesn't work in IEs.\n    var re = /([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,\n        blocks = [],\n        m;\n\n    var line_no = 1;\n\n    if ( ( m = /^(\\s*\\n)/.exec(input) ) !== null ) {\n      // skip (but count) leading blank lines\n      line_no += count_lines( m[0] );\n      re.lastIndex = m[0].length;\n    }\n\n    while ( ( m = re.exec(input) ) !== null ) {\n      if (m[2] === \"\\n#\") {\n        m[2] = \"\\n\";\n        re.lastIndex--;\n      }\n      blocks.push( mk_block( m[1], m[2], line_no ) );\n      line_no += count_lines( m[0] );\n    }\n\n    return blocks;\n  };\n\n  /**\n   *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n   *  - block (String): the block to process\n   *  - next (Array): the following blocks\n   *\n   * Process `block` and return an array of JsonML nodes representing `block`.\n   *\n   * It does this by asking each block level function in the dialect to process\n   * the block until one can. Succesful handling is indicated by returning an\n   * array (with zero or more JsonML nodes), failure by a false value.\n   *\n   * Blocks handlers are responsible for calling [[Markdown#processInline]]\n   * themselves as appropriate.\n   *\n   * If the blocks were split incorrectly or adjacent blocks need collapsing you\n   * can adjust `next` in place using shift/splice etc.\n   *\n   * If any of this default behaviour is not right for the dialect, you can\n   * define a `__call__` method on the dialect that will get invoked to handle\n   * the block processing.\n   */\n  Markdown.prototype.processBlock = function processBlock( block, next ) {\n    var cbs = this.dialect.block,\n        ord = cbs.__order__;\n\n    if ( \"__call__\" in cbs )\n      return cbs.__call__.call(this, block, next);\n\n    for ( var i = 0; i < ord.length; i++ ) {\n      //D:this.debug( \"Testing\", ord[i] );\n      var res = cbs[ ord[i] ].call( this, block, next );\n      if ( res ) {\n        //D:this.debug(\"  matched\");\n        if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\n          this.debug(ord[i], \"didn't return a proper array\");\n        //D:this.debug( \"\" );\n        return res;\n      }\n    }\n\n    // Uhoh! no match! Should we throw an error?\n    return [];\n  };\n\n  Markdown.prototype.processInline = function processInline( block ) {\n    return this.dialect.inline.__call__.call( this, String( block ) );\n  };\n\n  /**\n   *  Markdown#toTree( source ) -> JsonML\n   *  - source (String): markdown source to parse\n   *\n   *  Parse `source` into a JsonML tree representing the markdown document.\n   **/\n  // custom_tree means set this.tree to `custom_tree` and restore old value on return\n  Markdown.prototype.toTree = function toTree( source, custom_root ) {\n    var blocks = source instanceof Array ? source : this.split_blocks( source );\n\n    // Make tree a member variable so its easier to mess with in extensions\n    var old_tree = this.tree;\n    try {\n      this.tree = custom_root || this.tree || [ \"markdown\" ];\n\n      blocks_loop:\n      while ( blocks.length ) {\n        var b = this.processBlock( blocks.shift(), blocks );\n\n        // Reference blocks and the like won't return any content\n        if ( !b.length )\n          continue blocks_loop;\n\n        this.tree.push.apply( this.tree, b );\n      }\n      return this.tree;\n    }\n    finally {\n      if ( custom_root )\n        this.tree = old_tree;\n    }\n  };\n\n  // Noop by default\n  Markdown.prototype.debug = function () {\n    var args = Array.prototype.slice.call( arguments);\n    args.unshift(this.debug_indent);\n    if ( typeof print !== \"undefined\" )\n      print.apply( print, args );\n    if ( typeof console !== \"undefined\" && typeof console.log !== \"undefined\" )\n      console.log.apply( null, args );\n  };\n\n  Markdown.prototype.loop_re_over_block = function( re, block, cb ) {\n    // Dont use /g regexps with this\n    var m,\n        b = block.valueOf();\n\n    while ( b.length && (m = re.exec(b) ) !== null ) {\n      b = b.substr( m[0].length );\n      cb.call(this, m);\n    }\n    return b;\n  };\n\n  // Build default order from insertion order.\n  Markdown.buildBlockOrder = function(d) {\n    var ord = [];\n    for ( var i in d ) {\n      if ( i === \"__order__\" || i === \"__call__\" )\n        continue;\n      ord.push( i );\n    }\n    d.__order__ = ord;\n  };\n\n  // Build patterns for inline matcher\n  Markdown.buildInlinePatterns = function(d) {\n    var patterns = [];\n\n    for ( var i in d ) {\n      // __foo__ is reserved and not a pattern\n      if ( i.match( /^__.*__$/) )\n        continue;\n      var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\n               .replace( /\\n/, \"\\\\n\" );\n      patterns.push( i.length === 1 ? l : \"(?:\" + l + \")\" );\n    }\n\n    patterns = patterns.join(\"|\");\n    d.__patterns__ = patterns;\n    //print(\"patterns:\", uneval( patterns ) );\n\n    var fn = d.__call__;\n    d.__call__ = function(text, pattern) {\n      if ( pattern !== undefined )\n        return fn.call(this, text, pattern);\n      else\n        return fn.call(this, text, patterns);\n    };\n  };\n\n\n\n\n  var extract_attr = MarkdownHelpers.extract_attr;\n\n  /**\n   *  renderJsonML( jsonml[, options] ) -> String\n   *  - jsonml (Array): JsonML array to render to XML\n   *  - options (Object): options\n   *\n   *  Converts the given JsonML into well-formed XML.\n   *\n   *  The options currently understood are:\n   *\n   *  - root (Boolean): wether or not the root node should be included in the\n   *    output, or just its children. The default `false` is to not include the\n   *    root itself.\n   */\n  Markdown.renderJsonML = function( jsonml, options ) {\n    options = options || {};\n    // include the root element in the rendered output?\n    options.root = options.root || false;\n\n    var content = [];\n\n    if ( options.root ) {\n      content.push( render_tree( jsonml ) );\n    }\n    else {\n      jsonml.shift(); // get rid of the tag\n      if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) )\n        jsonml.shift(); // get rid of the attributes\n\n      while ( jsonml.length )\n        content.push( render_tree( jsonml.shift() ) );\n    }\n\n    return content.join( \"\\n\\n\" );\n  };\n\n\n  /**\n   *  toHTMLTree( markdown, [dialect] ) -> JsonML\n   *  toHTMLTree( md_tree ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n   *  to this function, it is first parsed into a markdown tree by calling\n   *  [[parse]].\n   **/\n  Markdown.toHTMLTree = function toHTMLTree( input, dialect , options ) {\n\n    // convert string input to an MD tree\n    if ( typeof input === \"string\" )\n      input = this.parse( input, dialect );\n\n    // Now convert the MD tree to an HTML tree\n\n    // remove references from the tree\n    var attrs = extract_attr( input ),\n        refs = {};\n\n    if ( attrs && attrs.references )\n      refs = attrs.references;\n\n    var html = convert_tree_to_html( input, refs , options );\n    merge_text_nodes( html );\n    return html;\n  };\n\n  /**\n   *  toHTML( markdown, [dialect]  ) -> String\n   *  toHTML( md_tree ) -> String\n   *  - markdown (String): markdown string to parse\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Take markdown (either as a string or as a JsonML tree) and run it through\n   *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n   **/\n  Markdown.toHTML = function toHTML( source , dialect , options ) {\n    var input = this.toHTMLTree( source , dialect , options );\n\n    return this.renderJsonML( input );\n  };\n\n\n  function escapeHTML( text ) {\n    return text.replace( /&/g, \"&amp;\" )\n               .replace( /</g, \"&lt;\" )\n               .replace( />/g, \"&gt;\" )\n               .replace( /\"/g, \"&quot;\" )\n               .replace( /'/g, \"&#39;\" );\n  }\n\n  function render_tree( jsonml ) {\n    // basic case\n    if ( typeof jsonml === \"string\" )\n      return escapeHTML( jsonml );\n\n    var tag = jsonml.shift(),\n        attributes = {},\n        content = [];\n\n    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) )\n      attributes = jsonml.shift();\n\n    while ( jsonml.length )\n      content.push( render_tree( jsonml.shift() ) );\n\n    var tag_attrs = \"\";\n    for ( var a in attributes )\n      tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\n\n    // be careful about adding whitespace here for inline elements\n    if ( tag === \"img\" || tag === \"br\" || tag === \"hr\" )\n      return \"<\"+ tag + tag_attrs + \"/>\";\n    else\n      return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\n  }\n\n  function convert_tree_to_html( tree, references, options ) {\n    var i;\n    options = options || {};\n\n    // shallow clone\n    var jsonml = tree.slice( 0 );\n\n    if ( typeof options.preprocessTreeNode === \"function\" )\n      jsonml = options.preprocessTreeNode(jsonml, references);\n\n    // Clone attributes if they exist\n    var attrs = extract_attr( jsonml );\n    if ( attrs ) {\n      jsonml[ 1 ] = {};\n      for ( i in attrs ) {\n        jsonml[ 1 ][ i ] = attrs[ i ];\n      }\n      attrs = jsonml[ 1 ];\n    }\n\n    // basic case\n    if ( typeof jsonml === \"string\" )\n      return jsonml;\n\n    // convert this node\n    switch ( jsonml[ 0 ] ) {\n    case \"header\":\n      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\n      delete jsonml[ 1 ].level;\n      break;\n    case \"bulletlist\":\n      jsonml[ 0 ] = \"ul\";\n      break;\n    case \"numberlist\":\n      jsonml[ 0 ] = \"ol\";\n      break;\n    case \"listitem\":\n      jsonml[ 0 ] = \"li\";\n      break;\n    case \"para\":\n      jsonml[ 0 ] = \"p\";\n      break;\n    case \"markdown\":\n      jsonml[ 0 ] = \"html\";\n      if ( attrs )\n        delete attrs.references;\n      break;\n    case \"code_block\":\n      jsonml[ 0 ] = \"pre\";\n      i = attrs ? 2 : 1;\n      var code = [ \"code\" ];\n      code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );\n      jsonml[ i ] = code;\n      break;\n    case \"inlinecode\":\n      jsonml[ 0 ] = \"code\";\n      break;\n    case \"img\":\n      jsonml[ 1 ].src = jsonml[ 1 ].href;\n      delete jsonml[ 1 ].href;\n      break;\n    case \"linebreak\":\n      jsonml[ 0 ] = \"br\";\n      break;\n    case \"link\":\n      jsonml[ 0 ] = \"a\";\n      break;\n    case \"link_ref\":\n      jsonml[ 0 ] = \"a\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.href = ref.href;\n        if ( ref.title )\n          attrs.title = ref.title;\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n    case \"img_ref\":\n      jsonml[ 0 ] = \"img\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.src = ref.href;\n        if ( ref.title )\n          attrs.title = ref.title;\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n    }\n\n    // convert all the children\n    i = 1;\n\n    // deal with the attribute node, if it exists\n    if ( attrs ) {\n      // if there are keys, skip over it\n      for ( var key in jsonml[ 1 ] ) {\n        i = 2;\n        break;\n      }\n      // if there aren't, remove it\n      if ( i === 1 )\n        jsonml.splice( i, 1 );\n    }\n\n    for ( ; i < jsonml.length; ++i ) {\n      jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );\n    }\n\n    return jsonml;\n  }\n\n\n  // merges adjacent text nodes into a single node\n  function merge_text_nodes( jsonml ) {\n    // skip the tag name and attribute hash\n    var i = extract_attr( jsonml ) ? 2 : 1;\n\n    while ( i < jsonml.length ) {\n      // if it's a string check the next item too\n      if ( typeof jsonml[ i ] === \"string\" ) {\n        if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\n          // merge the second string into the first and remove it\n          jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\n        }\n        else {\n          ++i;\n        }\n      }\n      // if it's not a string recurse\n      else {\n        merge_text_nodes( jsonml[ i ] );\n        ++i;\n      }\n    }\n  };\n\n\n\n  var DialectHelpers = {};\n  DialectHelpers.inline_until_char = function( text, want ) {\n    var consumed = 0,\n        nodes = [];\n\n    while ( true ) {\n      if ( text.charAt( consumed ) === want ) {\n        // Found the character we were looking for\n        consumed++;\n        return [ consumed, nodes ];\n      }\n\n      if ( consumed >= text.length ) {\n        // No closing char found. Abort.\n        return null;\n      }\n\n      var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );\n      consumed += res[ 0 ];\n      // Add any returned nodes.\n      nodes.push.apply( nodes, res.slice( 1 ) );\n    }\n  };\n\n  // Helper function to make sub-classing a dialect easier\n  DialectHelpers.subclassDialect = function( d ) {\n    function Block() {}\n    Block.prototype = d.block;\n    function Inline() {}\n    Inline.prototype = d.inline;\n\n    return { block: new Block(), inline: new Inline() };\n  };\n\n\n\n\n  var forEach = MarkdownHelpers.forEach,\n      extract_attr = MarkdownHelpers.extract_attr,\n      mk_block = MarkdownHelpers.mk_block,\n      isEmpty = MarkdownHelpers.isEmpty,\n      inline_until_char = DialectHelpers.inline_until_char;\n\n  /**\n   * Gruber dialect\n   *\n   * The default dialect that follows the rules set out by John Gruber's\n   * markdown.pl as closely as possible. Well actually we follow the behaviour of\n   * that script which in some places is not exactly what the syntax web page\n   * says.\n   **/\n  var Gruber = {\n    block: {\n      atxHeader: function atxHeader( block, next ) {\n        var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\n\n        if ( !m )\n          return undefined;\n\n        var header = [ \"header\", { level: m[ 1 ].length } ];\n        Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\n\n        if ( m[0].length < block.length )\n          next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n        return [ header ];\n      },\n\n      setextHeader: function setextHeader( block, next ) {\n        var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\n\n        if ( !m )\n          return undefined;\n\n        var level = ( m[ 2 ] === \"=\" ) ? 1 : 2,\n            header = [ \"header\", { level : level }, m[ 1 ] ];\n\n        if ( m[0].length < block.length )\n          next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n        return [ header ];\n      },\n\n      code: function code( block, next ) {\n        // |    Foo\n        // |bar\n        // should be a code block followed by a paragraph. Fun\n        //\n        // There might also be adjacent code block to merge.\n\n        var ret = [],\n            re = /^(?: {0,3}\\t| {4})(.*)\\n?/;\n\n        // 4 spaces + content\n        if ( !block.match( re ) )\n          return undefined;\n\n        block_search:\n        do {\n          // Now pull out the rest of the lines\n          var b = this.loop_re_over_block(\n                    re, block.valueOf(), function( m ) { ret.push( m[1] ); } );\n\n          if ( b.length ) {\n            // Case alluded to in first comment. push it back on as a new block\n            next.unshift( mk_block(b, block.trailing) );\n            break block_search;\n          }\n          else if ( next.length ) {\n            // Check the next block - it might be code too\n            if ( !next[0].match( re ) )\n              break block_search;\n\n            // Pull how how many blanks lines follow - minus two to account for .join\n            ret.push ( block.trailing.replace(/[^\\n]/g, \"\").substring(2) );\n\n            block = next.shift();\n          }\n          else {\n            break block_search;\n          }\n        } while ( true );\n\n        return [ [ \"code_block\", ret.join(\"\\n\") ] ];\n      },\n\n      horizRule: function horizRule( block, next ) {\n        // this needs to find any hr in the block to handle abutting blocks\n        var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\n\n        if ( !m )\n          return undefined;\n\n        var jsonml = [ [ \"hr\" ] ];\n\n        // if there's a leading abutting block, process it\n        if ( m[ 1 ] ) {\n          var contained = mk_block( m[ 1 ], \"\", block.lineNumber );\n          jsonml.unshift.apply( jsonml, this.toTree( contained, [] ) );\n        }\n\n        // if there's a trailing abutting block, stick it into next\n        if ( m[ 3 ] )\n          next.unshift( mk_block( m[ 3 ], block.trailing, block.lineNumber + 1 ) );\n\n        return jsonml;\n      },\n\n      // There are two types of lists. Tight and loose. Tight lists have no whitespace\n      // between the items (and result in text just in the <li>) and loose lists,\n      // which have an empty line between list items, resulting in (one or more)\n      // paragraphs inside the <li>.\n      //\n      // There are all sorts weird edge cases about the original markdown.pl's\n      // handling of lists:\n      //\n      // * Nested lists are supposed to be indented by four chars per level. But\n      //   if they aren't, you can get a nested list by indenting by less than\n      //   four so long as the indent doesn't match an indent of an existing list\n      //   item in the 'nest stack'.\n      //\n      // * The type of the list (bullet or number) is controlled just by the\n      //    first item at the indent. Subsequent changes are ignored unless they\n      //    are for nested lists\n      //\n      lists: (function( ) {\n        // Use a closure to hide a few variables.\n        var any_list = \"[*+-]|\\\\d+\\\\.\",\n            bullet_list = /[*+-]/,\n            // Capture leading indent as it matters for determining nested lists.\n            is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\n            indent_re = \"(?: {0,3}\\\\t| {4})\";\n\n        // TODO: Cache this regexp for certain depths.\n        // Create a regexp suitable for matching an li for a given stack depth\n        function regex_for_depth( depth ) {\n\n          return new RegExp(\n            // m[1] = indent, m[2] = list_type\n            \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\n            // m[3] = cont\n            \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\n          );\n        }\n        function expand_tab( input ) {\n          return input.replace( / {0,3}\\t/g, \"    \" );\n        }\n\n        // Add inline content `inline` to `li`. inline comes from processInline\n        // so is an array of content\n        function add(li, loose, inline, nl) {\n          if ( loose ) {\n            li.push( [ \"para\" ].concat(inline) );\n            return;\n          }\n          // Hmmm, should this be any block level element or just paras?\n          var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] === \"para\"\n                     ? li[li.length -1]\n                     : li;\n\n          // If there is already some content in this list, add the new line in\n          if ( nl && li.length > 1 )\n            inline.unshift(nl);\n\n          for ( var i = 0; i < inline.length; i++ ) {\n            var what = inline[i],\n                is_str = typeof what === \"string\";\n            if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] === \"string\" )\n              add_to[ add_to.length-1 ] += what;\n            else\n              add_to.push( what );\n          }\n        }\n\n        // contained means have an indent greater than the current one. On\n        // *every* line in the block\n        function get_contained_blocks( depth, blocks ) {\n\n          var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\n              replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n              ret = [];\n\n          while ( blocks.length > 0 ) {\n            if ( re.exec( blocks[0] ) ) {\n              var b = blocks.shift(),\n                  // Now remove that indent\n                  x = b.replace( replace, \"\");\n\n              ret.push( mk_block( x, b.trailing, b.lineNumber ) );\n            }\n            else\n              break;\n          }\n          return ret;\n        }\n\n        // passed to stack.forEach to turn list items up the stack into paras\n        function paragraphify(s, i, stack) {\n          var list = s.list;\n          var last_li = list[list.length-1];\n\n          if ( last_li[1] instanceof Array && last_li[1][0] === \"para\" )\n            return;\n          if ( i + 1 === stack.length ) {\n            // Last stack frame\n            // Keep the same array, but replace the contents\n            last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ) );\n          }\n          else {\n            var sublist = last_li.pop();\n            last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ), sublist );\n          }\n        }\n\n        // The matcher function\n        return function( block, next ) {\n          var m = block.match( is_list_re );\n          if ( !m )\n            return undefined;\n\n          function make_list( m ) {\n            var list = bullet_list.exec( m[2] )\n                     ? [\"bulletlist\"]\n                     : [\"numberlist\"];\n\n            stack.push( { list: list, indent: m[1] } );\n            return list;\n          }\n\n\n          var stack = [], // Stack of lists for nesting.\n              list = make_list( m ),\n              last_li,\n              loose = false,\n              ret = [ stack[0].list ],\n              i;\n\n          // Loop to search over block looking for inner block elements and loose lists\n          loose_search:\n          while ( true ) {\n            // Split into lines preserving new lines at end of line\n            var lines = block.split( /(?=\\n)/ );\n\n            // We have to grab all lines for a li and call processInline on them\n            // once as there are some inline things that can span lines.\n            var li_accumulate = \"\", nl = \"\";\n\n            // Loop over the lines in this block looking for tight lists.\n            tight_search:\n            for ( var line_no = 0; line_no < lines.length; line_no++ ) {\n              nl = \"\";\n              var l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\"; });\n\n\n              // TODO: really should cache this\n              var line_re = regex_for_depth( stack.length );\n\n              m = l.match( line_re );\n              //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n\n              // We have a list item\n              if ( m[1] !== undefined ) {\n                // Process the previous list item, if any\n                if ( li_accumulate.length ) {\n                  add( last_li, loose, this.processInline( li_accumulate ), nl );\n                  // Loose mode will have been dealt with. Reset it\n                  loose = false;\n                  li_accumulate = \"\";\n                }\n\n                m[1] = expand_tab( m[1] );\n                var wanted_depth = Math.floor(m[1].length/4)+1;\n                //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n                if ( wanted_depth > stack.length ) {\n                  // Deep enough for a nested list outright\n                  //print ( \"new nested list\" );\n                  list = make_list( m );\n                  last_li.push( list );\n                  last_li = list[1] = [ \"listitem\" ];\n                }\n                else {\n                  // We aren't deep enough to be strictly a new level. This is\n                  // where Md.pl goes nuts. If the indent matches a level in the\n                  // stack, put it there, else put it one deeper then the\n                  // wanted_depth deserves.\n                  var found = false;\n                  for ( i = 0; i < stack.length; i++ ) {\n                    if ( stack[ i ].indent !== m[1] )\n                      continue;\n\n                    list = stack[ i ].list;\n                    stack.splice( i+1, stack.length - (i+1) );\n                    found = true;\n                    break;\n                  }\n\n                  if (!found) {\n                    //print(\"not found. l:\", uneval(l));\n                    wanted_depth++;\n                    if ( wanted_depth <= stack.length ) {\n                      stack.splice(wanted_depth, stack.length - wanted_depth);\n                      //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n                      list = stack[wanted_depth-1].list;\n                      //print(\"list:\", uneval(list) );\n                    }\n                    else {\n                      //print (\"made new stack for messy indent\");\n                      list = make_list(m);\n                      last_li.push(list);\n                    }\n                  }\n\n                  //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n                  last_li = [ \"listitem\" ];\n                  list.push(last_li);\n                } // end depth of shenegains\n                nl = \"\";\n              }\n\n              // Add content\n              if ( l.length > m[0].length )\n                li_accumulate += nl + l.substr( m[0].length );\n            } // tight_search\n\n            if ( li_accumulate.length ) {\n              add( last_li, loose, this.processInline( li_accumulate ), nl );\n              // Loose mode will have been dealt with. Reset it\n              loose = false;\n              li_accumulate = \"\";\n            }\n\n            // Look at the next block - we might have a loose list. Or an extra\n            // paragraph for the current li\n            var contained = get_contained_blocks( stack.length, next );\n\n            // Deal with code blocks or properly nested lists\n            if ( contained.length > 0 ) {\n              // Make sure all listitems up the stack are paragraphs\n              forEach( stack, paragraphify, this);\n\n              last_li.push.apply( last_li, this.toTree( contained, [] ) );\n            }\n\n            var next_block = next[0] && next[0].valueOf() || \"\";\n\n            if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\n              block = next.shift();\n\n              // Check for an HR following a list: features/lists/hr_abutting\n              var hr = this.dialect.block.horizRule( block, next );\n\n              if ( hr ) {\n                ret.push.apply(ret, hr);\n                break;\n              }\n\n              // Make sure all listitems up the stack are paragraphs\n              forEach( stack, paragraphify, this);\n\n              loose = true;\n              continue loose_search;\n            }\n            break;\n          } // loose_search\n\n          return ret;\n        };\n      })(),\n\n      blockquote: function blockquote( block, next ) {\n        if ( !block.match( /^>/m ) )\n          return undefined;\n\n        var jsonml = [];\n\n        // separate out the leading abutting block, if any. I.e. in this case:\n        //\n        //  a\n        //  > b\n        //\n        if ( block[ 0 ] !== \">\" ) {\n          var lines = block.split( /\\n/ ),\n              prev = [],\n              line_no = block.lineNumber;\n\n          // keep shifting lines until you find a crotchet\n          while ( lines.length && lines[ 0 ][ 0 ] !== \">\" ) {\n            prev.push( lines.shift() );\n            line_no++;\n          }\n\n          var abutting = mk_block( prev.join( \"\\n\" ), \"\\n\", block.lineNumber );\n          jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );\n          // reassemble new block of just block quotes!\n          block = mk_block( lines.join( \"\\n\" ), block.trailing, line_no );\n        }\n\n\n        // if the next block is also a blockquote merge it in\n        while ( next.length && next[ 0 ][ 0 ] === \">\" ) {\n          var b = next.shift();\n          block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );\n        }\n\n        // Strip off the leading \"> \" and re-process as a block.\n        var input = block.replace( /^> ?/gm, \"\" ),\n            old_tree = this.tree,\n            processedBlock = this.toTree( input, [ \"blockquote\" ] ),\n            attr = extract_attr( processedBlock );\n\n        // If any link references were found get rid of them\n        if ( attr && attr.references ) {\n          delete attr.references;\n          // And then remove the attribute object if it's empty\n          if ( isEmpty( attr ) )\n            processedBlock.splice( 1, 1 );\n        }\n\n        jsonml.push( processedBlock );\n        return jsonml;\n      },\n\n      referenceDefn: function referenceDefn( block, next) {\n        var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\n        // interesting matches are [ , ref_id, url, , title, title ]\n\n        if ( !block.match(re) )\n          return undefined;\n\n        // make an attribute node if it doesn't exist\n        if ( !extract_attr( this.tree ) )\n          this.tree.splice( 1, 0, {} );\n\n        var attrs = extract_attr( this.tree );\n\n        // make a references hash if it doesn't exist\n        if ( attrs.references === undefined )\n          attrs.references = {};\n\n        var b = this.loop_re_over_block(re, block, function( m ) {\n\n          if ( m[2] && m[2][0] === \"<\" && m[2][m[2].length-1] === \">\" )\n            m[2] = m[2].substring( 1, m[2].length - 1 );\n\n          var ref = attrs.references[ m[1].toLowerCase() ] = {\n            href: m[2]\n          };\n\n          if ( m[4] !== undefined )\n            ref.title = m[4];\n          else if ( m[5] !== undefined )\n            ref.title = m[5];\n\n        } );\n\n        if ( b.length )\n          next.unshift( mk_block( b, block.trailing ) );\n\n        return [];\n      },\n\n      para: function para( block ) {\n        // everything's a para!\n        return [ [\"para\"].concat( this.processInline( block ) ) ];\n      }\n    },\n\n    inline: {\n\n      __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {\n        var m,\n            res;\n\n        patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\n        var re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\" );\n\n        m = re.exec( text );\n        if (!m) {\n          // Just boring text\n          return [ text.length, text ];\n        }\n        else if ( m[1] ) {\n          // Some un-interesting text matched. Return that first\n          return [ m[1].length, m[1] ];\n        }\n\n        var res;\n        if ( m[2] in this.dialect.inline ) {\n          res = this.dialect.inline[ m[2] ].call(\n                    this,\n                    text.substr( m.index ), m, previous_nodes || [] );\n        }\n        // Default for now to make dev easier. just slurp special and output it.\n        res = res || [ m[2].length, m[2] ];\n        return res;\n      },\n\n      __call__: function inline( text, patterns ) {\n\n        var out = [],\n            res;\n\n        function add(x) {\n          //D:self.debug(\"  adding output\", uneval(x));\n          if ( typeof x === \"string\" && typeof out[out.length-1] === \"string\" )\n            out[ out.length-1 ] += x;\n          else\n            out.push(x);\n        }\n\n        while ( text.length > 0 ) {\n          res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );\n          text = text.substr( res.shift() );\n          forEach(res, add );\n        }\n\n        return out;\n      },\n\n      // These characters are intersting elsewhere, so have rules for them so that\n      // chunks of plain text blocks don't include them\n      \"]\": function () {},\n      \"}\": function () {},\n\n      __escape__ : /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\n\n      \"\\\\\": function escaped( text ) {\n        // [ length of input processed, node/children to add... ]\n        // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n        if ( this.dialect.inline.__escape__.exec( text ) )\n          return [ 2, text.charAt( 1 ) ];\n        else\n          // Not an esacpe\n          return [ 1, \"\\\\\" ];\n      },\n\n      \"![\": function image( text ) {\n\n        // Unlike images, alt text is plain text only. no other elements are\n        // allowed in there\n\n        // ![Alt text](/path/to/img.jpg \"Optional title\")\n        //      1          2            3       4         <--- captures\n        var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n\n        if ( m ) {\n          if ( m[2] && m[2][0] === \"<\" && m[2][m[2].length-1] === \">\" )\n            m[2] = m[2].substring( 1, m[2].length - 1 );\n\n          m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n\n          var attrs = { alt: m[1], href: m[2] || \"\" };\n          if ( m[4] !== undefined)\n            attrs.title = m[4];\n\n          return [ m[0].length, [ \"img\", attrs ] ];\n        }\n\n        // ![Alt text][id]\n        m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\n\n        if ( m ) {\n          // We can't check if the reference is known here as it likely wont be\n          // found till after. Check it in md tree->hmtl tree conversion\n          return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];\n        }\n\n        // Just consume the '!['\n        return [ 2, \"![\" ];\n      },\n\n      \"[\": function link( text ) {\n\n        var orig = String(text);\n        // Inline content is possible inside `link text`\n        var res = inline_until_char.call( this, text.substr(1), \"]\" );\n\n        // No closing ']' found. Just consume the [\n        if ( !res )\n          return [ 1, \"[\" ];\n\n        var consumed = 1 + res[ 0 ],\n            children = res[ 1 ],\n            link,\n            attrs;\n\n        // At this point the first [...] has been parsed. See what follows to find\n        // out which kind of link we are (reference or direct url)\n        text = text.substr( consumed );\n\n        // [link text](/path/to/img.jpg \"Optional title\")\n        //                 1            2       3         <--- captures\n        // This will capture up to the last paren in the block. We then pull\n        // back based on if there a matching ones in the url\n        //    ([here](/url/(test))\n        // The parens have to be balanced\n        var m = text.match( /^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/ );\n        if ( m ) {\n          var url = m[1];\n          consumed += m[0].length;\n\n          if ( url && url[0] === \"<\" && url[url.length-1] === \">\" )\n            url = url.substring( 1, url.length - 1 );\n\n          // If there is a title we don't have to worry about parens in the url\n          if ( !m[3] ) {\n            var open_parens = 1; // One open that isn't in the capture\n            for ( var len = 0; len < url.length; len++ ) {\n              switch ( url[len] ) {\n              case \"(\":\n                open_parens++;\n                break;\n              case \")\":\n                if ( --open_parens === 0) {\n                  consumed -= url.length - len;\n                  url = url.substring(0, len);\n                }\n                break;\n              }\n            }\n          }\n\n          // Process escapes only\n          url = this.dialect.inline.__call__.call( this, url, /\\\\/ )[0];\n\n          attrs = { href: url || \"\" };\n          if ( m[3] !== undefined)\n            attrs.title = m[3];\n\n          link = [ \"link\", attrs ].concat( children );\n          return [ consumed, link ];\n        }\n\n        // [Alt text][id]\n        // [Alt text] [id]\n        m = text.match( /^\\s*\\[(.*?)\\]/ );\n\n        if ( m ) {\n\n          consumed += m[ 0 ].length;\n\n          // [links][] uses links as its reference\n          attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };\n\n          link = [ \"link_ref\", attrs ].concat( children );\n\n          // We can't check if the reference is known here as it likely wont be\n          // found till after. Check it in md tree->hmtl tree conversion.\n          // Store the original so that conversion can revert if the ref isn't found.\n          return [ consumed, link ];\n        }\n\n        // [id]\n        // Only if id is plain (no formatting.)\n        if ( children.length === 1 && typeof children[0] === \"string\" ) {\n\n          attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };\n          link = [ \"link_ref\", attrs, children[0] ];\n          return [ consumed, link ];\n        }\n\n        // Just consume the \"[\"\n        return [ 1, \"[\" ];\n      },\n\n\n      \"<\": function autoLink( text ) {\n        var m;\n\n        if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) !== null ) {\n          if ( m[3] )\n            return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\n          else if ( m[2] === \"mailto\" )\n            return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\n          else\n            return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\n        }\n\n        return [ 1, \"<\" ];\n      },\n\n      \"`\": function inlineCode( text ) {\n        // Inline code block. as many backticks as you like to start it\n        // Always skip over the opening ticks.\n        var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\n\n        if ( m && m[2] )\n          return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\n        else {\n          // TODO: No matching end code found - warn!\n          return [ 1, \"`\" ];\n        }\n      },\n\n      \"  \\n\": function lineBreak() {\n        return [ 3, [ \"linebreak\" ] ];\n      }\n\n    }\n  };\n\n  // Meta Helper/generator method for em and strong handling\n  function strong_em( tag, md ) {\n\n    var state_slot = tag + \"_state\",\n        other_slot = tag === \"strong\" ? \"em_state\" : \"strong_state\";\n\n    function CloseTag(len) {\n      this.len_after = len;\n      this.name = \"close_\" + md;\n    }\n\n    return function ( text ) {\n\n      if ( this[state_slot][0] === md ) {\n        // Most recent em is of this type\n        //D:this.debug(\"closing\", md);\n        this[state_slot].shift();\n\n        // \"Consume\" everything to go back to the recrusion in the else-block below\n        return[ text.length, new CloseTag(text.length-md.length) ];\n      }\n      else {\n        // Store a clone of the em/strong states\n        var other = this[other_slot].slice(),\n            state = this[state_slot].slice();\n\n        this[state_slot].unshift(md);\n\n        //D:this.debug_indent += \"  \";\n\n        // Recurse\n        var res = this.processInline( text.substr( md.length ) );\n        //D:this.debug_indent = this.debug_indent.substr(2);\n\n        var last = res[res.length - 1];\n\n        //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n\n        var check = this[state_slot].shift();\n        if ( last instanceof CloseTag ) {\n          res.pop();\n          // We matched! Huzzah.\n          var consumed = text.length - last.len_after;\n          return [ consumed, [ tag ].concat(res) ];\n        }\n        else {\n          // Restore the state of the other kind. We might have mistakenly closed it.\n          this[other_slot] = other;\n          this[state_slot] = state;\n\n          // We can't reuse the processed result as it could have wrong parsing contexts in it.\n          return [ md.length, md ];\n        }\n      }\n    }; // End returned function\n  }\n\n  Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\n  Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\n  Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\n  Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\n\n  Markdown.dialects.Gruber = Gruber;\n  Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\n  Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\n\n\n\n  var Maruku = DialectHelpers.subclassDialect( Gruber ),\n      extract_attr = MarkdownHelpers.extract_attr,\n      forEach = MarkdownHelpers.forEach;\n\n  Maruku.processMetaHash = function processMetaHash( meta_string ) {\n    var meta = split_meta_hash( meta_string ),\n        attr = {};\n\n    for ( var i = 0; i < meta.length; ++i ) {\n      // id: #foo\n      if ( /^#/.test( meta[ i ] ) )\n        attr.id = meta[ i ].substring( 1 );\n      // class: .foo\n      else if ( /^\\./.test( meta[ i ] ) ) {\n        // if class already exists, append the new one\n        if ( attr[\"class\"] )\n          attr[\"class\"] = attr[\"class\"] + meta[ i ].replace( /./, \" \" );\n        else\n          attr[\"class\"] = meta[ i ].substring( 1 );\n      }\n      // attribute: foo=bar\n      else if ( /\\=/.test( meta[ i ] ) ) {\n        var s = meta[ i ].split( /\\=/ );\n        attr[ s[ 0 ] ] = s[ 1 ];\n      }\n    }\n\n    return attr;\n  };\n\n  function split_meta_hash( meta_string ) {\n    var meta = meta_string.split( \"\" ),\n        parts = [ \"\" ],\n        in_quotes = false;\n\n    while ( meta.length ) {\n      var letter = meta.shift();\n      switch ( letter ) {\n      case \" \" :\n        // if we're in a quoted section, keep it\n        if ( in_quotes )\n          parts[ parts.length - 1 ] += letter;\n        // otherwise make a new part\n        else\n          parts.push( \"\" );\n        break;\n      case \"'\" :\n      case '\"' :\n        // reverse the quotes and move straight on\n        in_quotes = !in_quotes;\n        break;\n      case \"\\\\\" :\n        // shift off the next letter to be used straight away.\n        // it was escaped so we'll keep it whatever it is\n        letter = meta.shift();\n        /* falls through */\n      default :\n        parts[ parts.length - 1 ] += letter;\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  Maruku.block.document_meta = function document_meta( block ) {\n    // we're only interested in the first block\n    if ( block.lineNumber > 1 )\n      return undefined;\n\n    // document_meta blocks consist of one or more lines of `Key: Value\\n`\n    if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) )\n      return undefined;\n\n    // make an attribute node if it doesn't exist\n    if ( !extract_attr( this.tree ) )\n      this.tree.splice( 1, 0, {} );\n\n    var pairs = block.split( /\\n/ );\n    for ( var p in pairs ) {\n      var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\n          key = m[ 1 ].toLowerCase(),\n          value = m[ 2 ];\n\n      this.tree[ 1 ][ key ] = value;\n    }\n\n    // document_meta produces no content!\n    return [];\n  };\n\n  Maruku.block.block_meta = function block_meta( block ) {\n    // check if the last line of the block is an meta hash\n    var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\n    if ( !m )\n      return undefined;\n\n    // process the meta hash\n    var attr = this.dialect.processMetaHash( m[ 2 ] ),\n        hash;\n\n    // if we matched ^ then we need to apply meta to the previous block\n    if ( m[ 1 ] === \"\" ) {\n      var node = this.tree[ this.tree.length - 1 ];\n      hash = extract_attr( node );\n\n      // if the node is a string (rather than JsonML), bail\n      if ( typeof node === \"string\" )\n        return undefined;\n\n      // create the attribute hash if it doesn't exist\n      if ( !hash ) {\n        hash = {};\n        node.splice( 1, 0, hash );\n      }\n\n      // add the attributes in\n      for ( var a in attr )\n        hash[ a ] = attr[ a ];\n\n      // return nothing so the meta hash is removed\n      return [];\n    }\n\n    // pull the meta hash off the block and process what's left\n    var b = block.replace( /\\n.*$/, \"\" ),\n        result = this.processBlock( b, [] );\n\n    // get or make the attributes hash\n    hash = extract_attr( result[ 0 ] );\n    if ( !hash ) {\n      hash = {};\n      result[ 0 ].splice( 1, 0, hash );\n    }\n\n    // attach the attributes to the block\n    for ( var a in attr )\n      hash[ a ] = attr[ a ];\n\n    return result;\n  };\n\n  Maruku.block.definition_list = function definition_list( block, next ) {\n    // one or more terms followed by one or more definitions, in a single block\n    var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\n        list = [ \"dl\" ],\n        i, m;\n\n    // see if we're dealing with a tight or loose block\n    if ( ( m = block.match( tight ) ) ) {\n      // pull subsequent tight DL blocks out of `next`\n      var blocks = [ block ];\n      while ( next.length && tight.exec( next[ 0 ] ) )\n        blocks.push( next.shift() );\n\n      for ( var b = 0; b < blocks.length; ++b ) {\n        var m = blocks[ b ].match( tight ),\n            terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\n            defns = m[ 2 ].split( /\\n:\\s+/ );\n\n        // print( uneval( m ) );\n\n        for ( i = 0; i < terms.length; ++i )\n          list.push( [ \"dt\", terms[ i ] ] );\n\n        for ( i = 0; i < defns.length; ++i ) {\n          // run inline processing over the definition\n          list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\n        }\n      }\n    }\n    else {\n      return undefined;\n    }\n\n    return [ list ];\n  };\n\n  // splits on unescaped instances of @ch. If @ch is not a character the result\n  // can be unpredictable\n\n  Maruku.block.table = function table ( block ) {\n\n    var _split_on_unescaped = function( s, ch ) {\n      ch = ch || '\\\\s';\n      if ( ch.match(/^[\\\\|\\[\\]{}?*.+^$]$/) )\n        ch = '\\\\' + ch;\n      var res = [ ],\n          r = new RegExp('^((?:\\\\\\\\.|[^\\\\\\\\' + ch + '])*)' + ch + '(.*)'),\n          m;\n      while ( ( m = s.match( r ) ) ) {\n        res.push( m[1] );\n        s = m[2];\n      }\n      res.push(s);\n      return res;\n    };\n\n    var leading_pipe = /^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        // find at least an unescaped pipe in each line\n        no_leading_pipe = /^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        i,\n        m;\n    if ( ( m = block.match( leading_pipe ) ) ) {\n      // remove leading pipes in contents\n      // (header and horizontal rule already have the leading pipe left out)\n      m[3] = m[3].replace(/^\\s*\\|/gm, '');\n    } else if ( ! ( m = block.match( no_leading_pipe ) ) ) {\n      return undefined;\n    }\n\n    var table = [ \"table\", [ \"thead\", [ \"tr\" ] ], [ \"tbody\" ] ];\n\n    // remove trailing pipes, then split on pipes\n    // (no escaped pipes are allowed in horizontal rule)\n    m[2] = m[2].replace(/\\|\\s*$/, '').split('|');\n\n    // process alignment\n    var html_attrs = [ ];\n    forEach (m[2], function (s) {\n      if (s.match(/^\\s*-+:\\s*$/))\n        html_attrs.push({align: \"right\"});\n      else if (s.match(/^\\s*:-+\\s*$/))\n        html_attrs.push({align: \"left\"});\n      else if (s.match(/^\\s*:-+:\\s*$/))\n        html_attrs.push({align: \"center\"});\n      else\n        html_attrs.push({});\n    });\n\n    // now for the header, avoid escaped pipes\n    m[1] = _split_on_unescaped(m[1].replace(/\\|\\s*$/, ''), '|');\n    for (i = 0; i < m[1].length; i++) {\n      table[1][1].push(['th', html_attrs[i] || {}].concat(\n        this.processInline(m[1][i].trim())));\n    }\n\n    // now for body contents\n    forEach (m[3].replace(/\\|\\s*$/mg, '').split('\\n'), function (row) {\n      var html_row = ['tr'];\n      row = _split_on_unescaped(row, '|');\n      for (i = 0; i < row.length; i++)\n        html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));\n      table[2].push(html_row);\n    }, this);\n\n    return [table];\n  };\n\n  Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n    if ( !out.length )\n      return [ 2, \"{:\" ];\n\n    // get the preceeding element\n    var before = out[ out.length - 1 ];\n\n    if ( typeof before === \"string\" )\n      return [ 2, \"{:\" ];\n\n    // match a meta hash\n    var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\n\n    // no match, false alarm\n    if ( !m )\n      return [ 2, \"{:\" ];\n\n    // attach the attributes to the preceeding element\n    var meta = this.dialect.processMetaHash( m[ 1 ] ),\n        attr = extract_attr( before );\n\n    if ( !attr ) {\n      attr = {};\n      before.splice( 1, 0, attr );\n    }\n\n    for ( var k in meta )\n      attr[ k ] = meta[ k ];\n\n    // cut out the string and replace it with nothing\n    return [ m[ 0 ].length, \"\" ];\n  };\n\n\n  Markdown.dialects.Maruku = Maruku;\n  Markdown.dialects.Maruku.inline.__escape__ = /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/;\n  Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\n  Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\n\n\n// Include all our depndencies and;\n  expose.Markdown = Markdown;\n  expose.parse = Markdown.parse;\n  expose.toHTML = Markdown.toHTML;\n  expose.toHTMLTree = Markdown.toHTMLTree;\n  expose.renderJsonML = Markdown.renderJsonML;\n\n})(window);\n"],"sourceRoot":"/source/"}